package bangfe.managers{	import bangfe.ui.BasicButton;		import flash.text.TextField;		import system.data.Iterator;	import system.data.collections.ArrayCollection;	import system.data.maps.HashMap;
		/**	 * Localization Manager. Mines XML for localized strings. 	 * @author Will Zadikian	 * 	 */	public class LocalizationManager	{				//--------------------------------------		//  PUBLIC STATIC CONSTANTS		//--------------------------------------		public static const SINGLETON_ERROR_MESSAGE : String = "You cannnot instantiate this class directly. Please use the api class method"				//--------------------------------------		//  PRIVATE STATIC VARIABLES		//--------------------------------------		private static var _instance : LocalizationManager;						//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var _localizedDataCollection : HashMap = new HashMap();		private var _bindeeCollection : ArrayCollection = new ArrayCollection();				//--------------------------------------		//  PUBLIC STATIC METHODS		//--------------------------------------		/**		 * The LocalizationManager instance.		 * @return 		 * 		 */		public static function get api () : LocalizationManager		{			if(_instance == null)_instance = new LocalizationManager(new SingletonEnforcer());			return _instance;		}				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Constructor 		 * @param enforcer Enforce the use as a singleton		 * 		 */		public function LocalizationManager( enforcer : SingletonEnforcer )		{			if(!(enforcer is SingletonEnforcer))throw new Error(SINGLETON_ERROR_MESSAGE);			trace("Created LocalizationManager, make sure to give it some data!");		}				/**		 * Get a localized string based on a node name. If nothing is found, the default text supplied will be returned. 		 * @param p_stringID		 * @param p_defaultText		 * @return 		 * 		 */		public function getLocalizedString ( p_stringID : String, p_defaultString : String = "Default") : String		{			if(!_localizedDataCollection.containsKey(p_stringID))return p_defaultString;						return _localizedDataCollection.get(p_stringID);		}				/**		 * Bind a function or textfield to a stringID. If xml data is changed these will be updated		 * @param p_bindee A Function or TextField		 * @param p_stringID The ID of the localized node to bind to		 * @param p_updateNow Should the binding be updated immidiately or wait till an update occurs		 * @return 		 * 		 */		public function bind ( p_bindee : *, p_stringID : String, p_updateNow : Boolean = true) : void		{			if(hasBinding(p_bindee))unBind(p_bindee);						var bindingItem : Object = {bindee:p_bindee, stringID:p_stringID};			_bindeeCollection.add(bindingItem);			if(p_updateNow)updateBindingItem(bindingItem);		}				/**		 * Unbind a function or textfield in the binding collection.		 * @param p_bindee The Function or TextField to unbind		 * @param p_stringID The ID of the localized node to unbind		 * @return 		 * 		 */		public function unBind ( p_bindee : *) : void		{			var it : Iterator = _bindeeCollection.iterator();						while(it.hasNext()){				var bindingItem : Object = it.next() as Object;				if((bindingItem["bindee"] == p_bindee)){					_bindeeCollection.remove(bindingItem);				}			}		}				/**		 * Clear all bindings 		 * 		 */		public function clearAllBindings () : void		{			_bindeeCollection.clear();		}				/**		 * Clear the localized data 		 * 		 */				public function clearData () : void		{			_localizedDataCollection.clear();		}				/**		 * Adds localized data to the localization collection.		 * Any conflicting properties will be overwritten with the new data		 * @param p_data		 * 		 */				public function addLocalizedData ( p_data : XMLList ) : void		{			for each(var node : XML in p_data.children()){				_localizedDataCollection.put(new String(node.name()), new String(node.text()));			}						updateBindings();		}		//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------		private function updateBindings () : void		{			var it : Iterator = _bindeeCollection.iterator();						while(it.hasNext()){				updateBindingItem(it.next() as Object);			}		}				private function updateBindingItem ( p_item : Object ) : void		{			//Is it a TextField			if(p_item["bindee"] is TextField){				p_item["bindee"].text = getLocalizedString(p_item["stringID"]);			}						//Is it a BasicButton			if(p_item["bindee"] is BasicButton){				p_item["bindee"].label = getLocalizedString(p_item["stringID"]);			}						//Is it a Function			if(p_item["bindee"] is Function){				p_item["bindee"].apply(this, [getLocalizedString(p_item["stringID"])]);			}		}				private function hasBinding ( p_bindee : * ) : Boolean		{			var it : Iterator = _bindeeCollection.iterator();						while(it.hasNext()){				var bindingItem : Object = it.next() as Object;				if(bindingItem["bindee"] == p_bindee)return true;			}						return false;		}			}}/** * Singleton Enforcer  * @author Will Zadikian *  */internal class SingletonEnforcer{}