package bangfe.managers{	import bangfe.core.ICoreObject;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;		import org.osflash.signals.Signal;		import system.data.Iterator;	import system.data.collections.ArrayCollection;		public class IdleMouseManager implements ICoreObject	{				//--------------------------------------		//  SIGNALS		//--------------------------------------		/**		 * Signal - Dispatched when the user mouse idles.		 * Handler must expect no required arguments		 */				public var idledSignal : Signal = new Signal();				/**		 * Signal - Dispatched when the user mouse re activates (Moves).		 * Handler must expect no required arguments 		 */				public var activatedSignal : Signal = new Signal();				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var _safeChildrenCollection : ArrayCollection = new ArrayCollection();		private var _idleTime : int = 1000;		private var _timer : Timer;		private var _isDestroyed : Boolean = false;		private var _elapsedTime : int = 0;		private var _scope : DisplayObjectContainer;		private var _lastTimeStamp : Date;		private var _isIdle : Boolean = false;		private var _isTracking : Boolean = false;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Constructor 		 * @param target		 * 		 */		public function IdleMouseManager( p_scope : DisplayObjectContainer )		{			if(p_scope != null)scope = p_scope;			init();		}				/** @inheritDoc */			public function destroy () : void		{			if(_isDestroyed)return;			_isDestroyed = true;			_timer.stop();			removeListeners();		}				/**		 * Add a child to the safe list. When the timer count runs out, if this child		 * is currently under the mouse, the countdown will reset 		 * @param p_displayObject		 * 		 */				public function addSafeChild ( p_displayObject : DisplayObject ) : void		{			_safeChildrenCollection.add(p_displayObject);		}				/**		 * Remove a child from the safelist 		 * @param p_displayObject		 * 		 */				public function removeSafeChild ( p_displayObject : DisplayObject ) : void		{			if(_safeChildrenCollection.contains(p_displayObject))_safeChildrenCollection.remove(p_displayObject);		}				/**		 * Start the idle countdown 		 * 		 */				public function start () : void		{			if(isDestroyed)return;			if(!scope)throw new Error("You must set scope before you can start IdleMouseManager");			if(_isTracking)return;						_isTracking = true;						addListeners();						_lastTimeStamp = new Date();			_timer.start();		}				/**		 * Stop the idle countdown 		 * 		 */				public function stop ( p_autoActivate : Boolean = false ) : void		{			if(isDestroyed)return;						if(!p_autoActivate)removeListeners();						if(!_isTracking)return;						_isTracking = false; 						_lastTimeStamp = null;			_timer.reset();		}				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * Is the manager currently idle 		 * @return 		 * 		 */				public function get isIdle () : Boolean		{			return _isIdle;		}				/**		 * The time the user must not move the mouse to become idle.		 * Note, if the user is hovering a safe child, the manager will never idle 		 * @return 		 * 		 */				public function get idleTime () : int		{			return _idleTime;		}				public function set idleTime ( p_idleTime : int ) : void		{			_idleTime = p_idleTime;		}				/**		 * The time elapsed since the last mouse move 		 * @return 		 * 		 */				public function get elapsedTime () : int		{			return _elapsedTime;		}				/**		 * Has this manager been destroyed 		 * @return 		 * 		 */				public function get isDestroyed () : Boolean		{			return _isDestroyed;		}				/**		 * The scope to add listeners to 		 * @return 		 * 		 */				public function get scope () : DisplayObjectContainer		{			return _scope;		}		public function set scope ( p_scope : DisplayObjectContainer) : void		{			try{				_scope.stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			}catch(e:Error){}						_scope = p_scope;		}				//--------------------------------------		//  SETUP METHODS		//--------------------------------------		private function init () : void		{			setDefaults();		}				private function setDefaults () : void		{			_timer = new Timer(100, int.MAX_VALUE);		}				private function addListeners () : void		{			_timer.addEventListener(TimerEvent.TIMER, timerTickHandler, false, 0, true);			_scope.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler, false,  0, true);		}				private function removeListeners () : void		{			_timer.removeEventListener(TimerEvent.TIMER, timerTickHandler);						try{				scope.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			}catch(e:Error){}		}				//--------------------------------------		//  PRIVATE METHODS - LOGIC		//--------------------------------------		private function resetElapsedTime () : void		{			_elapsedTime = 0;			processInteractionActivated();		}				private function checkIdleStatus () : void		{			calculateElapsedTime();						if(isHoveringSafeChild()){				resetElapsedTime();			}else if(elapsedTime >= idleTime){				processInteractionIdled()			}		}				private function calculateElapsedTime () : void		{			var newTimeStamp : Date = new Date();			_elapsedTime +=  (newTimeStamp.getTime() - _lastTimeStamp.getTime());			_lastTimeStamp = newTimeStamp;		}				private function isHoveringSafeChild () : Boolean		{			var it : Iterator = _safeChildrenCollection.iterator();						while(it.hasNext()){				var child : DisplayObject = it.next() as DisplayObject;				if(child.stage){					if(child.hitTestPoint(child.stage.mouseX, child.stage.mouseY)){						return true;					}				}			}						return false;		}				private function processInteractionIdled () : void		{			if(isDestroyed)return;			if(isIdle)return;						_isIdle = true;						stop(true);						idledSignal.dispatch();		}				private function processInteractionActivated () : void		{			if(isDestroyed)return;			if(!isIdle)return;			_isIdle = false;						start();						activatedSignal.dispatch();		}				//--------------------------------------		//  HANDLER METHODS		//--------------------------------------				private function timerTickHandler ( e : TimerEvent ) : void		{			checkIdleStatus();		}				private function mouseMoveHandler ( e : MouseEvent ) : void		{			resetElapsedTime();		}			}}