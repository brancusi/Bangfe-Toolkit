package bangfe.managers{	import bangfe.core.ICoreObject;	import bangfe.events.LazyInteractionEvent;		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.TimerEvent;	import flash.utils.Timer;		import system.data.Iterator;	import system.data.collections.ArrayCollection;		/**	 * Dispatched the interaction idles	 *	 * @eventType bangfe.events.LazyInteractionEvent.INTERACTION_IDLED	 */				[Event(name="interactionIdled", type="bangfe.events.LazyInteractionEvent")]		public class LazyInteractionManager extends EventDispatcher implements ICoreObject	{				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var _safeChildrenCollection : ArrayCollection = new ArrayCollection();		private var _idleTime : Number = 1000;		private var _timer : Timer;		private var _autoDestroy : Boolean = true;		private var _isDestroyed : Boolean = false;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Constructor 		 * @param target		 * 		 */		public function LazyInteractionManager( autoDestroy : Boolean = true )		{			super(null);			this.autoDestroy = autoDestroy;			init();		}				/**		 * Add a child to the safe list. When the timer count runs out, if this child		 * is currently under the mouse, the countdown will reset 		 * @param p_displayObject		 * 		 */				public function addSafeChild ( p_displayObject : DisplayObject ) : void		{			_safeChildrenCollection.add(p_displayObject);		}				/**		 * Remove a child from the safelist 		 * @param p_displayObject		 * 		 */				public function removeSafeChild ( p_displayObject : DisplayObject ) : void		{			if(_safeChildrenCollection.contains(p_displayObject))_safeChildrenCollection.remove(p_displayObject);		}				/**		 * Start the idle countdown 		 * 		 */				public function start () : void		{			if(isDestroyed)return;			_timer.start();		}				/**		 * Stop the idle countdown 		 * 		 */				public function stop () : void		{			if(isDestroyed)return;			_timer.reset();			}				public function destroy () : void		{			stop();			removeListeners();		}				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		public function get idleTime () : Number		{			return _idleTime;		}		public function set idleTime ( p_idleTime : Number ) : void		{			_idleTime = p_idleTime;			_timer.delay = _idleTime;		}				/**		 * Should this manager auto destroy when idled 		 * @return 		 * 		 */				public function get autoDestroy () : Boolean		{			return _autoDestroy;		}		public function set autoDestroy ( p_autoDestroy : Boolean ) : void		{			_autoDestroy = p_autoDestroy;		}				/**		 * Has this manager been destroyed 		 * @return 		 * 		 */				public function get isDestroyed () : Boolean		{			return _isDestroyed;		}		public function set isDestroyed ( p_isDestroyed : Boolean ) : void		{			_isDestroyed = p_isDestroyed;		}				//--------------------------------------		//  SETUP METHODS		//--------------------------------------		private function init () : void		{			setDefaults();			addListeners();		}				private function setDefaults () : void		{			_timer = new Timer(idleTime);			_timer.repeatCount = 0;		}				private function addListeners () : void		{			_timer.addEventListener(TimerEvent.TIMER, timerTickHandler, false, 0, true);		}				private function removeListeners () : void		{			_timer.removeEventListener(TimerEvent.TIMER, timerTickHandler);			}				//--------------------------------------		//  PRIVATE METHODS - LOGIC		//--------------------------------------		private function checkIdleStatus () : void		{			var hasIdled : Boolean = true;			var it : Iterator = _safeChildrenCollection.iterator();						while(it.hasNext()){				var child : DisplayObject = it.next() as DisplayObject;				if(child.stage){					if(child.hitTestPoint(child.stage.mouseX, child.stage.mouseY)){						hasIdled = false;					}				}else{					hasIdled = false;				}			}						if(hasIdled)processInteractionIdled();		}				private function processInteractionIdled () : void		{			if(isDestroyed)return;			stop();			var event : LazyInteractionEvent = new LazyInteractionEvent(LazyInteractionEvent.INTERACTION_IDLED);			event.safeChildrenCollection = _safeChildrenCollection.clone();			dispatchEvent(event);						if(autoDestroy)destroy();		}		//--------------------------------------		//  HANDLER METHODS		//--------------------------------------				private function timerTickHandler ( e : TimerEvent ) : void		{			checkIdleStatus();		}			}}