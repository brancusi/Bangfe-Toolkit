package bangfe.batchloader{	import bangfe.batchloader.core.ILoaderItem;	import bangfe.batchloader.events.BatchLoaderEvent;	import bangfe.batchloader.events.LoaderItemEvent;	import bangfe.batchloader.ioc.ContentRequest;	import bangfe.batchloader.utils.BatchLoaderUtils;	import bangfe.utils.CountDownTimer;		import flash.events.EventDispatcher;	import flash.events.TimerEvent;		import system.data.Iterator;	import system.data.maps.HashMap;	/**	* Dispatched when single item completes and is ready for consumption	*	* @eventType com.bangfe.batchloader.events.BatchLoaderEvent.COLLECTION_PROGRESS	*/				[Event(name="collectionProgress", type="com.bangfe.batchloader.events.BatchLoaderEvent")]		/**	* Dispatched when all items complete and are ready for consumption	*	* @eventType com.bangfe.batchloader.events.BatchLoaderEvent.COLLECTION_COMPLETE	*/				[Event(name="collectionComplete", type="com.bangfe.batchloader.events.BatchLoaderEvent")]		/**	 * BatchLoader	 * @author Will Zadikian	 * 	 */		public class BatchLoader extends EventDispatcher	{				//--------------------------------------		//  PROTECTED VARIABLES		//--------------------------------------		protected var _itemCollection : HashMap = new HashMap();		protected var _failedCollection : HashMap = new HashMap();		protected var _queuedCollection : HashMap = new HashMap();		protected var _injectionRequestQueue : HashMap = new HashMap();				protected var _isPaused : Boolean = false;				protected var _maxConnections : uint = 3;		protected var _delayTimer : CountDownTimer = new CountDownTimer();				protected var _isDelayMode : Boolean = false;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------				/**		 * Constructor 		 * 		 */				public function BatchLoader()		{			init();		}				/**		 * Add single item to queue 		 * @param p_item		 * 		 */				public function addItem ( p_item : String, p_uid : String = null ) : void		{			queueItem(p_item, p_uid);		}				/**		 * Add array of items to queue 		 * @param p_items		 * 		 */				public function addCollection ( p_items : Array ) : void		{			var pauseAndResume : Boolean = !isPaused;						pause();						for(var i : int = 0; i < p_items.length; i++){				var item : Object = p_items[i];				queueItem(item["url"], item["uid"]);			}						if(pauseAndResume)resume();		}				/**		 * Inject content when ready. Basic Inversion of Control implmentation 		 * @param p_item Item UID to wait for		 * @param p_onReady OnReady callback function		 * @param p_params Extra paramters, <code>overwrite</code>, <code>onReadyParams</code>		 * 		 */				public function injectContent ( p_item : String, p_onReady : Function, p_params : Object = null ) : void		{			var contentRequest : ContentRequest = new ContentRequest();			contentRequest.uid = p_item;			contentRequest.injectionFunction = p_onReady;						if(p_params){				if(p_params.onReadyParams)contentRequest.injectionFunctionParams = p_params.onReadyParams;				if(p_params.overwrite != null)contentRequest.overwrite = p_params.overwrite;			}	            addInjectionRequest(contentRequest);		}				/**		 * Check if the Mgr has this item 		 * @param p_item Item uid to check for		 * @param p_onlySearchCompleted Should it search only completed items		 * @return 		 * 		 */				public function hasItem ( p_uid : String, p_onlySearchCompleted : Boolean = true ) : Boolean		{			var itemCheck : Boolean = _itemCollection.containsKey(p_uid);						if(p_onlySearchCompleted)return itemCheck;						if(_failedCollection.containsKey(p_uid) || _queuedCollection.containsKey(p_uid))itemCheck = true;                        return itemCheck;		}				/**		 * Get the matching <code>LoaderItem</code> 		 * @param p_item		 * @return 		 * 		 */				public function getItem( p_uid : String ) : ILoaderItem		{			return _itemCollection.get(p_uid) as ILoaderItem		}				/**		 * Get content from the <code>LoaderItem</code> 		 * @param p_item		 * @return 		 * 		 */				public function getContent ( p_uid : String ) : *		{			if(hasItem(p_uid))return getItem(p_uid).content;						return false;		}				/**		 * Pause all Loading 		 * 		 */				public function pause () : void		{			if(isPaused)return;						isPaused = true;						var it : Iterator = _queuedCollection.iterator();						while(it.hasNext()){				var item : ILoaderItem = it.next() as ILoaderItem;				item.pause();			}		}				/**		 * Resume all Loading 		 * 		 */				public function resume () : void		{			if(!isPaused)return;						isPaused = false;			var it : Iterator = _queuedCollection.iterator();						while(it.hasNext()){				var item : ILoaderItem = it.next() as ILoaderItem;				item.resume();			}            processQueue();		}				//--------------------------------------		//  ACCESSOR METHODS		//--------------------------------------				/**		 * Is the <code>BatchLoader</code> paused 		 * @return 		 * 		 */				public function get isPaused () : Boolean 		{			return _isPaused; 		}		public function set isPaused ( p_isPaused : Boolean ) : void 		{ 			_isPaused = p_isPaused; 		}				/**		 * Number of connections to open at any given time 		 * @return 		 * 		 */				public function get maxConnections () : uint 		{			return _maxConnections; 		}		public function set maxConnections ( p_maxConnections : uint ) : void 		{ 			_maxConnections = p_maxConnections; 		}				//--------------------------------------		//  PROTECTED METHODS		//--------------------------------------				protected function init () : void		{			_delayTimer.duration = 100;			_delayTimer.bind(delayHandler);		}				protected function queueItem ( p_url : String, p_uid : String = null ) : void		{			if(hasItem(p_url, false))return;						var loaderDef : Class = BatchLoaderUtils.getTypeDefinition( p_url );						var item : ILoaderItem = new loaderDef(p_url) as ILoaderItem;			if(p_uid)item.uid = p_uid; 			//Set default props			item.isPaused = isPaused;						//Add listeners			item.addEventListener(LoaderItemEvent.OPENED, itemOpenedHandler);			item.addEventListener(LoaderItemEvent.CLOSED, itemClosedHandler);			item.addEventListener(LoaderItemEvent.COMPLETED, itemCompletedHandler);			item.addEventListener(LoaderItemEvent.FAILED, itemFailedHandler);						_queuedCollection.put(item.uid, item);						processQueue();		}				/**		 * Process loader item queue 		 * 		 */				protected function processQueue () : void		{			validateQueue();						if(isPaused)return;			var it : Iterator = _queuedCollection.iterator();						while(it.hasNext()){								if(maxConnectionsReached())return;				if(_isDelayMode)return;								startDelayMode();												var item : ILoaderItem = it.next() as ILoaderItem;								if(!item.isLoading)item.load();			}		}				/**		 * Add injection request to queue 		 * @param p_request		 * 		 */				protected function addInjectionRequest ( p_request : ContentRequest ) : void		{			var it : Iterator = _injectionRequestQueue.iterator();						while(it.hasNext()){				var item : ContentRequest = it.next() as ContentRequest;				if (item.injectionFunction == p_request.injectionFunction && p_request.overwrite) removeInjectionRequest(item);			}                        _injectionRequestQueue.put(p_request.uid, p_request);            			processInjectionQueue();						if(!hasItem( p_request.uid, false))addItem(p_request.uid);		}				/**		 * Remove injection request from queue 		 * @param p_request		 * @return 		 * 		 */				protected function removeInjectionRequest ( p_request : ContentRequest ) : ContentRequest		{			return _injectionRequestQueue.remove(p_request.uid);		}				/**		 * Process injection queue 		 * 		 */				protected function processInjectionQueue () : void		{			var it : Iterator = _injectionRequestQueue.iterator();						while(it.hasNext()){				var item : ContentRequest = it.next() as ContentRequest;				if (hasItem(item.uid))processInjectionRequest(item);			}		}				/**		 * Process a request when loaditem content is available 		 * @param p_request		 * 		 */				protected function processInjectionRequest ( p_request : ContentRequest ) : void		{			if(!hasItem(p_request.uid))return;						var contentRequest : ContentRequest = removeInjectionRequest(p_request);						var injectionFunction : Function = contentRequest.injectionFunction;						var loaderItem : ILoaderItem = _itemCollection.get(contentRequest.uid) as ILoaderItem;			var content : * = loaderItem.content;						var args : Array = contentRequest.injectionFunctionParams;			args.splice(0, 0, content);						injectionFunction.apply(null, args);		}				//--------------------------------------		//  HELPER METHODS		//--------------------------------------				protected function startDelayMode () : void		{			_isDelayMode = true;			_delayTimer.reset();		}				/**		 * Validate the queue items. Will clean failed items from queue 		 * 		 */				protected function validateQueue () : void		{			var it : Iterator = _queuedCollection.iterator();						while(it.hasNext()){				var item : ILoaderItem = it.next() as ILoaderItem;				if (item.isFailed) _failedCollection.put(item.uid, _queuedCollection.remove(item.uid));			}		}					/**		 * Checks against currently queued items isLoading property 		 * @return 		 * 		 */				protected function maxConnectionsReached () : Boolean		{			var count : int = 0;			            var it : Iterator = _queuedCollection.iterator();						while(it.hasNext()){				var item : ILoaderItem = it.next() as ILoaderItem;				if (item.isLoading) count++;			}            			return count >= _maxConnections;		}				/**		 * Check for global load complete status 		 * 		 */				protected function checkGlobalStatus () : void		{			if(_queuedCollection.size() < 1 )dispatchEvent(new BatchLoaderEvent(BatchLoaderEvent.COLLECTION_COMPLETE));		}				//--------------------------------------		//  HANDLER METHODS		//--------------------------------------				protected function itemOpenedHandler ( e : LoaderItemEvent ) : void		{			//trace("Opened");		}				protected function itemClosedHandler ( e : LoaderItemEvent ) : void		{			//trace("Closed");		}				protected function itemCompletedHandler ( e : LoaderItemEvent ) : void		{			var item : ILoaderItem = e.target as ILoaderItem;						_itemCollection.put(item.uid, _queuedCollection.remove(item.uid));						dispatchEvent(new BatchLoaderEvent(BatchLoaderEvent.COLLECTION_PROGRESS));						processQueue();			processInjectionQueue();			checkGlobalStatus();					}				protected function itemFailedHandler ( e : LoaderItemEvent ) : void		{			var item : ILoaderItem = e.target as ILoaderItem;						_failedCollection.put(item.uid, _queuedCollection.remove(item.uid));			processQueue();		}				protected function delayHandler () : void		{			_isDelayMode = false;						processQueue();			processInjectionQueue();			checkGlobalStatus();		}			}}