package bangfe.ui.dd{	import bangfe.core.CoreDisplayObject;	import bangfe.utils.DisplayObjectUtils;		import com.greensock.TweenMax;		import flash.display.DisplayObject;	import flash.display.Shape;	import flash.display.Sprite;	import flash.errors.IllegalOperationError;	import flash.geom.Rectangle;		import org.osflash.signals.Signal;		import system.data.Iterator;	import system.data.collections.ArrayCollection;	import system.data.lists.ArrayList;
		/**	 * The BaseDropZone is a simple drop area for use with the <code>BaseDragDropItem</code>	 * It will catch dropped items and add them to an internal DisplayObjectContainer.	 * 	 * It tracks changes and updates positioning of managed items	 *  	 * @author Will Zadikian	 * 	 */		public class BaseDropZone extends CoreDisplayObject implements IDropZone	{				//--------------------------------------		//  PUBLIC STATIC CONSTANTS		//--------------------------------------		/**		 * The default state 		 */				public static const DEFAULT_STATE : String = "__defaultState__";				/**		 * The empty state 		 */				public static const EMPTY_STATE : String = "__emptyState__";				/**		 * The max child state 		 */				public static const MAX_CHILD_STATE : String = "__maxChildState__";				//--------------------------------------		//  SIGNALS		//--------------------------------------		/**		 * Signal - Item added to dropzone		 * Handler must expect following params:		 * 1) BaseDragDropItem		 */				public var itemAddedSignal : Signal = new Signal(BaseDragDropItem);				/**		 * Signal - Item removed from dropzone		 * Handler must expect following params:		 * 1) BaseDragDropItem		 */				public var itemRemovedSignal : Signal = new Signal(BaseDragDropItem);				/**		 * Signal - Child count changed		 * Handler must expect following params:		 * 1) int - Number of children 		 */				public var childCountChangedSignal : Signal = new Signal(int);				/**		 * Signal - Max child count reached for dropzone		 * Handler must expect following params:		 * 1) int - Number of children		 */			public var maxChildrenReachedSignal : Signal = new Signal(int);				/**		 * Signal - Child sorting changed		 * Handler must expect no required arguments 		 */				public var dropProcessedSignal : Signal = new Signal();				/**		 * Signal - Dropzone state change		 * Handler must expect following params:		 * 1) String - The new state 		 */				public var stateChangedSignal : Signal = new Signal(String);				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var _spaceX : Number = 5;		private var _maxChildren : Number = 10;		private var _itemStash : ArrayList = new ArrayList();		private var _fullyManagedCollection : ArrayList = new ArrayList();		private var _contentContainer : Sprite = new Sprite();		private var _state : String = EMPTY_STATE;		private var _dropZoneWidth : Number = 400;		private var _dropZoneHeight : Number = 400;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Add an item to the dropzone. Will be pushed to the last slot if not already being tracked via dragging 		 * @param p_item		 * @return Was the item added		 * 		 */				public function addItem ( p_item : BaseDragDropItem ) : Boolean		{			if(!fullyManagedCollection.contains(p_item) && hasReachedMaxChildren())return false;						if(!fullyManagedCollection.contains(p_item)){				_contentContainer.addChild(p_item);				fullyManagedCollection.add(p_item);				trackItem(p_item);								processChildCountChanged();				itemAddedSignal.dispatch(p_item);			}						if(!itemStash.contains(p_item))itemStash.add(p_item);						reAlignCollection();						return true;		}				/**		 * Remove an item from the dropzone		 * @param p_item The item to remove		 * @param p_forceDestroy Should the BaseDragDropItem be destroyed by force		 * @return Was the item removed		 * 		 */					public function removeItem ( p_item : BaseDragDropItem, p_forceDestroy : Boolean = false ) : Boolean		{			unTrackItem(p_item);						//Remove from the collections			itemStash.remove(p_item);			fullyManagedCollection.remove(p_item);						if(p_forceDestroy)p_item.destroy();						reAlignCollection();						itemRemovedSignal.dispatch(p_item);						processChildCountChanged();						return true;		}				/**		 * Clear the drop zone of all children 		 * 		 */				public function clear () : void		{			var it : Iterator = itemStash.iterator();						while(it.hasNext()){				var child : BaseDragDropItem = it.next() as BaseDragDropItem;				removeItem(child, true);				child.destroy();			}						//Clear and dispatch just in case we missed a stray item			itemStash.clear();			fullyManagedCollection.clear();			processChildCountChanged();		}				/**		 * Is the dropzone empty 		 * @return 		 * 		 */				public function isEmpty () : Boolean		{			return fullyManagedCollection.isEmpty();		}				/**		 * Has the maximum number of children been reached 		 * @return 		 * 		 */				public function hasReachedMaxChildren () : Boolean		{			return (childCount >= maxChildren);		}				/**		 * Force a refresh of the state 		 * 		 */				public function invalidate () : void		{			showCurrentState();		}				/**		 * Override wraps the addItem method. For clarity, it is best to use addItem directly 		 * @param child The child must be of type BaseDragDropItem		 * @return 		 * 		 */				override public function addChild(child:DisplayObject):DisplayObject		{			if(!(child is BaseDragDropItem))throw new IllegalOperationError("Only BaseDragDropItem instances can be added to the BaseDropZone");			addItem(child as BaseDragDropItem);						return child;		}				/**		 * Override wraps the removeItem method. For clarity, it is best to use addItem directly 		 * @param child The child must be of type BaseDragDropItem		 * @return 		 * 		 */				override public function removeChild(child:DisplayObject):DisplayObject		{			if(!(child is BaseDragDropItem))throw new IllegalOperationError("Only BaseDragDropItem instances can be added to the BaseDropZone");			removeItem(child as BaseDragDropItem, true);						return child;		}				override public function addChildAt(child:DisplayObject, index:int):DisplayObject		{			throw new IllegalOperationError("You cannot use addChildAt with the BaseDropZone");						return child;		}				override public function removeChildAt(index:int):DisplayObject		{			throw new IllegalOperationError("You cannot use removeChildAt with the BaseDropZone");						return null;		}				/**		 * This is used by a BaseDragItem. Whenever the item is over a dropzone, it will cast its shadow 		 * @param p_item		 * @return Was a shadow cast		 * 		 */		public function castShadow ( p_item : BaseDragDropItem ) : Boolean		{			if(hasReachedMaxChildren())return false;			trackItem(p_item);			return true;		}		//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * Current state of the dropzone 		 * @return 		 * 		 */				public function get state () : String		{			return _state;		}				public function set state ( p_state : String) : void		{			if(_state == p_state)return;			_state = p_state;						showCurrentState();						stateChangedSignal.dispatch(_state);		}				/**		 * The x space between items 		 * @return 		 * 		 */		public function get spaceX () : Number		{			return _spaceX;		}		public function set spaceX ( p_spaceX : Number) : void		{			_spaceX = p_spaceX;		}				/**		 * Number of children in the drop zone 		 * @return 		 * 		 */				public function get childCount () : int		{			return fullyManagedCollection.size();		}				/**		 * The maximum number of children this dropzone can manage 		 * @return 		 * 		 */				public function get maxChildren () : int		{			return _maxChildren;		}		public function set maxChildren ( p_maxChildren : int) : void		{			_maxChildren = p_maxChildren;		}				/**		 * The collection of items currently being managed 		 * @return 		 * 		 */				public function get itemStash () : ArrayList		{			return _itemStash;		}				/**		 * The collection of items that are fully managed.		 * i.e. Items that have been added to this stage and pushed into the sorted stack 		 * @return 		 * 		 */				public function get fullyManagedCollection () : ArrayList		{			return _fullyManagedCollection;		}				public function get dropZoneWidth () : Number 
		{
			return _dropZoneWidth;
		}
		
		public function set dropZoneWidth ( p_dropZoneWidth : Number ) : void
		{
			_dropZoneWidth = p_dropZoneWidth;			this.graphics.clear();			this.graphics.beginFill(0x000000, 0);			this.graphics.drawRect(0, 0, _dropZoneWidth, dropZoneHeight);			this.graphics.endFill();
		}				public function get dropZoneHeight () : Number 
		{
			return _dropZoneHeight;
		}
		
		public function set dropZoneHeight ( p_dropZoneHeight : Number ) : void
		{
			_dropZoneHeight = p_dropZoneHeight;			this.graphics.clear();			this.graphics.beginFill(0x000000, 0);			this.graphics.drawRect(0, 0, dropZoneWidth, _dropZoneHeight);			this.graphics.endFill();
		}				//--------------------------------------		//  PROTECTED METHODS		//--------------------------------------		override protected function setGlobalDefaults():void		{			super.addChild(_contentContainer);			invalidate();		}				//--------------------------------------		//  STATE METHODS		//--------------------------------------		/**		 * Show the empty state of the drop zone. State when there are no items in the drop 		 * 		 */				protected function showEmptyState () : void {/*Override*/}				/**		 * Show the default state of the drop zone. The state that can accept drops 		 * 		 */		protected function showDefaultState () : void {/*Override*/}				/**		 * Show the child max reached state. The state that does not except drops 		 * 		 */				protected function showMaxChildState () : void {/*Override*/}				//--------------------------------------		//  POSITIONING METHODS		//--------------------------------------		/**		 * Re-aligns the visible collection. This iterates through the collection and positions the items		 * @param p_activeItem The item currently being dragged or processed		 * @param p_force Should the collection realign even if nothing has changed		 * 		 */				protected function reAlignCollection (  p_speed : Number = .1 ) : void		{			var it : Iterator = itemStash.iterator();						var nextXPosition : Number = 0;			while(it.hasNext()){				var item : BaseDragDropItem = it.next() as BaseDragDropItem;								if(!item.isDragging){					item.y = 0;					TweenMax.to(item, .1, {x:nextXPosition, overwrite:1});				}								nextXPosition = (nextXPosition + item.width + spaceX);			}		}				/**		 * Calculates the correct index for the supplied item. 		 * @param p_activeItem The item to calcuate for		 * @return The correct index in the collection		 * 		 */				protected function calculateCorrectIndex (  p_activeItem : BaseDragDropItem ) : int		{			if(itemStash.isEmpty())return itemStash.size();						var it : Iterator = itemStash.iterator();			var bounds : Rectangle = p_activeItem.getBounds(_contentContainer);						//Use the middle of the clip x pos			var targetXPosition : Number = bounds.x + (bounds.width/2);						while(it.hasNext()){				var item : BaseDragDropItem = it.next() as BaseDragDropItem;								//We are basically looking for the item in the collection that corresponds to the ACTIVE item's x position				if((item != p_activeItem) && itemInRange(targetXPosition, item)){					if(targetXPosition < (item.x + (item.width/2))){						return (itemStash.indexOf(item));					}else{						return Math.min((itemStash.indexOf(item)+1), itemStash.size()-1);					}				}						}						return (itemStash.contains(p_activeItem))?itemStash.indexOf(p_activeItem):itemStash.size();		}				//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------		/**		 * Reslot the active item to its new location in the list 		 * @param p_activeItem The item being dragged or processed		 * @return Was the item successfully re-slotted		 * 		 */				protected function reSlotItem ( p_activeItem : BaseDragDropItem ) : Boolean		{			var previewActiveItemPosition : Boolean = (p_activeItem.currentDropZone == this);						if(previewActiveItemPosition){				var currentIndex : int = itemStash.indexOf(p_activeItem);				var projectedIndex : int = calculateCorrectIndex(p_activeItem);								if(projectedIndex != currentIndex){					var swapItem : BaseDragDropItem = itemStash.get(projectedIndex) as BaseDragDropItem;					itemStash.remove(swapItem);					itemStash.addAt(currentIndex, swapItem);										itemStash.remove(p_activeItem);					itemStash.addAt(projectedIndex, p_activeItem);					return true;				}else{					return false;				}			}						return itemStash.remove(p_activeItem);		}				//--------------------------------------		//  HELPER METHODS		//--------------------------------------		/**		 * Is the supplied x position in range for the specified display object 		 * @param p_xPosition The x position to check for		 * @param p_object The item to check the x position range within		 * @return 		 * 		 */				private function itemInRange ( p_xPosition : Number, p_object : DisplayObject ) : Boolean		{			return ((p_xPosition > p_object.x) && (p_xPosition < (p_object.x + p_object.width)));		}			//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------		private function processChildCountChanged () : void		{			if(isEmpty() && !hasReachedMaxChildren()){				state = EMPTY_STATE;			}						if(!isEmpty() && !hasReachedMaxChildren()){				state = DEFAULT_STATE;			}						if(hasReachedMaxChildren()){				state = MAX_CHILD_STATE;				maxChildrenReachedSignal.dispatch(maxChildren);			}						childCountChangedSignal.dispatch(childCount);		}				private function trackItem ( p_item : BaseDragDropItem ) : void		{			p_item.itemMovedSignal.add(processMoved);			p_item.itemDroppedSignal.add(processDropped);		}				private function unTrackItem ( p_item : BaseDragDropItem ) : void		{			p_item.itemMovedSignal.remove(processMoved);			p_item.itemDroppedSignal.remove(processDropped);		}				private function showCurrentState () : void		{			switch(_state){				case DEFAULT_STATE :					showDefaultState();					break;								case EMPTY_STATE :					showEmptyState();					break;								case MAX_CHILD_STATE :					showMaxChildState();					break;			}		}				//--------------------------------------		//  HANDLER METHODS		//--------------------------------------		private function processMoved ( p_item : BaseDragDropItem ) : void		{			if(reSlotItem(p_item))reAlignCollection();		}				private function processDropped ( p_item : BaseDragDropItem ) : void		{			if(p_item.currentDropZone != this){				removeItem(p_item, false);			}else{				addItem(p_item);			}						dropProcessedSignal.dispatch();		}			}}