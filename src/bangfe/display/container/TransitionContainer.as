package bangfe.display.container{	import bangfe.core.CoreDisplayObject;	import bangfe.core.ICoreObject;	import bangfe.core.ITransitionable;	import bangfe.events.TransitionItemManagerEvent;	import bangfe.events.TransitionableEvent;		import com.greensock.TweenMax;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.utils.Dictionary;		import graphics.transitions.Tween;		import system.data.Iterator;	import system.data.collections.ArrayCollection;	import system.data.maps.HashMap;
	/**	 * This is a simple transition container. Add a display object via addChild and the child will be transitioned on.	 * Old children will be transitioned off in an OUT then IN transition.	 * 	 * For detailed transitions implement the <code>ITransitionable</code> interface.	 * 	 * If an item implements <code>ICoreObject</code>, it's destroy method will be called instead of direct removal.	 * 	 * Check the examples for usage 	 *  	 * @author Will Zadikian	 * 	 */	public class TransitionContainer extends CoreDisplayObject	{				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------				private var _currentItemManager : TransitionItemManager;		private var _nextItemManager : TransitionItemManager;		private var _scope : DisplayObjectContainer;				private var _itemCollection : HashMap = new HashMap();				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Add a child to the <code>TransitionContainer</code>. If the display object		 * implements <code>ITransitionable</code> it will hook into its transition in and out		 * methods. Otherwie it will do a default fade in/out.		 *  		 * @param child		 * @return 		 * 		 */				override public function addChild(child:DisplayObject):DisplayObject		{						queueChild(child);			return child;			}				/**		 * Revmoe a child from the <code>TransitionContainer</code>. If the display object		 * implements <code>ITransitionable</code> it will hook into its transition in and out		 * methods. Otherwie it will do a default fade in/out.		 * @param child		 * @return 		 * 		 */				override public function removeChild(child:DisplayObject):DisplayObject		{			if(!_itemCollection.containsKey(child))return child;						var itemManager : TransitionItemManager = _itemCollection.get(child) as TransitionItemManager;			itemManager.transitionOut();			return child;		}				/**		 * Transition out all children of this container		 * 		 */		public function clear () : void		{			var it : Iterator = _itemCollection.iterator();			while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				item.transitionOut();			}		}				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * The scope to add the children to 		 * @return 		 * 		 */		public function get scope () : DisplayObjectContainer		{			return _scope;		}		public function set scope ( p_scope : DisplayObjectContainer ) : void		{			try{				super.removeChild(_scope);			}catch(e:Error){}			_scope = p_scope;			_scope.mouseEnabled = false;			if(!_scope.parent)super.addChild(_scope);		}				//--------------------------------------		//  PROTECTED METHODS		//--------------------------------------		override protected function setGlobalDefaults():void		{			this.mouseEnabled = false;			scope = new Sprite();		}				//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------		private function queueChild ( p_child : DisplayObject ) : void		{			destroyItemManager(_nextItemManager);			_nextItemManager = prepareItemManager(p_child);			transitionOutCurrent();		}				private function prepareItemManager ( p_child : DisplayObject ) : TransitionItemManager		{			var transitionItemManager : TransitionItemManager = new TransitionItemManager(scope);			transitionItemManager.item = p_child;			_itemCollection.put(p_child, transitionItemManager);						addItemManagerListeners(transitionItemManager);						return transitionItemManager;			}				private function destroyItemManager ( p_itemManager : TransitionItemManager = null ) : void		{			if(!p_itemManager)return;						_itemCollection.remove(p_itemManager.item);						removeItemManagerListeners(p_itemManager);						p_itemManager.destroy();		}				private function addItemManagerListeners ( p_itemManager : TransitionItemManager ) : void		{			try{				p_itemManager.addEventListener(TransitionItemManagerEvent.TRANSITION_IN_COMPLETE, transitionInCompleteHandler, false, 0, true);				p_itemManager.addEventListener(TransitionItemManagerEvent.TRANSITION_OUT_COMPLETE, transitionOutCompleteHandler, false, 0, true);			}catch(e:Error){}		}				private function removeItemManagerListeners ( p_itemManager : TransitionItemManager ) : void		{			try{				p_itemManager.removeEventListener(TransitionItemManagerEvent.TRANSITION_IN_COMPLETE, transitionInCompleteHandler);				p_itemManager.removeEventListener(TransitionItemManagerEvent.TRANSITION_OUT_COMPLETE, transitionOutCompleteHandler);			}catch(e:Error){}		}				private function transitionOutCurrent () : void		{			if(!_currentItemManager){				transitionInNext();				return;			}						_currentItemManager.transitionOut();		}				private function transitionInNext () : void		{			if(!_nextItemManager)return;						_currentItemManager = _nextItemManager;			_nextItemManager = null;			_currentItemManager.transitionIn();		}				//--------------------------------------		//  HANDLER METHODS		//--------------------------------------				private function transitionInCompleteHandler ( e : TransitionItemManagerEvent ) : void		{			//Nothing really needs to be done post intro, here in case we need to add init logic in the future		}				private function transitionOutCompleteHandler ( e : TransitionItemManagerEvent ) : void		{			destroyItemManager(_currentItemManager);			_currentItemManager = null;			transitionInNext();		}					}}