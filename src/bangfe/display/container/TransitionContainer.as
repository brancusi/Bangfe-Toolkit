package bangfe.display.container{	import bangfe.core.CoreDisplayObject;	import bangfe.core.ICoreObject;	import bangfe.core.ITransitionable;	import bangfe.events.TransitionableEvent;		import com.greensock.TweenMax;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.utils.Dictionary;		import graphics.transitions.Tween;		import org.osflash.signals.Signal;		import system.data.Iterator;	import system.data.collections.ArrayCollection;	import system.data.maps.HashMap;	/**	 * This is a simple transition container. Add a display object via addChild and the child will be transitioned on.	 * Old children will be transitioned off in an OUT then IN transition.	 * 	 * For detailed transitions implement the <code>ITransitionable</code> interface.	 * 	 * If an item implements <code>ICoreObject</code>, it's destroy method will be called instead of direct removal.	 * 	 * Check the examples for usage 	 *  	 * @author Will Zadikian	 * 	 */	public class TransitionContainer extends CoreDisplayObject	{				//--------------------------------------		//  SIGNALS		//--------------------------------------			public var queueCompletedIn : Signal = new Signal();		public var queueCompletedOut : Signal = new Signal();		public var itemCompletedOut : Signal = new Signal(TransitionItemManager);		public var itemCompletedIn : Signal = new Signal(TransitionItemManager);				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------				private var _queuedCollection : ArrayCollection = new ArrayCollection();		private var _arrivingCollection : ArrayCollection = new ArrayCollection();		private var _activeCollection : ArrayCollection = new ArrayCollection();		private var _exitingCollection : ArrayCollection = new ArrayCollection();		private var _maxChildren : uint;				private var _scope : DisplayObjectContainer;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Add a child to the <code>TransitionContainer</code>. If the display object		 * implements <code>ITransitionable</code> it will hook into its transition in and out		 * methods. Otherwie it will do a default fade in/out.		 *  		 * @param child		 * @return 		 * 		 */		override public function addChild ( child : DisplayObject ) : DisplayObject		{			if(!hasAvailableSlot())createEntrySlot();						var item : TransitionItemManager = prepareItemManager(child);			_queuedCollection.add(item);						processArrivals();						return child;		}				/**		 * Revmoe a child from the <code>TransitionContainer</code>. If the display object		 * implements <code>ITransitionable</code> it will hook into its transition in and out		 * methods. Otherwie it will do a default fade in/out.		 * @param child		 * @return 		 * 		 */				/*override public function removeChild(child:DisplayObject):DisplayObject		{			if(!_itemCollection.containsKey(child))return child;						var itemManager : TransitionItemManager = _itemCollection.get(child) as TransitionItemManager;			itemManager.transitionOut();			return child;		}*/				/**		 * Transition out all children of this container		 * 		 */		/*public function clear () : void		{			var it : Iterator = _itemCollection.iterator();			while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				item.transitionOut();			}		}*/				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * Is the container empty of transitioned and queued items 		 * @return 		 * 		 */		public function get isEmpty () : Boolean		{			return (_queuedCollection.isEmpty() && _arrivingCollection.isEmpty() && _activeCollection.isEmpty());		}				/**		 * The max number of children allowed by the container. When the max is reached,		 * the bottom item in the stack will be replaced with the new request. First In First Out.		 *  		 * @return 		 * 		 */				public function get maxChildren () : uint		{			return _maxChildren;		}		public function set maxChildren ( p_maxChildren : uint ) : void		{			_maxChildren = p_maxChildren;		}				/**		 * The container to add children to 		 * @return 		 * 		 */				public function get scope () : DisplayObjectContainer		{			return _scope;		}		public function set scope ( p_scope : DisplayObjectContainer ) : void		{			_scope = p_scope;		}				//--------------------------------------		//  PROTECTED METHODS		//--------------------------------------		override protected function setGlobalDefaults():void		{			maxChildren = uint.MAX_VALUE;						_scope = new Sprite();			super.addChild(_scope);			this.mouseEnabled = false;		}				//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------				private function prepareItemManager ( p_child : DisplayObject ) : TransitionItemManager		{			var transitionItemManager : TransitionItemManager = new TransitionItemManager(scope);			transitionItemManager.item = p_child;						addItemManagerListeners(transitionItemManager);						return transitionItemManager;			}				private function destroyItemManager ( p_itemManager : TransitionItemManager = null ) : void		{			if(!p_itemManager)return;						if(_exitingCollection.contains(p_itemManager))_exitingCollection.remove(p_itemManager);						removeItemManagerListeners(p_itemManager);						p_itemManager.destroy();		}				private function addItemManagerListeners ( p_itemManager : TransitionItemManager ) : void		{			try{				p_itemManager.transitionInCompleted.add(transitionInCompletedHandler);				p_itemManager.transitionOutCompleted.add(transitionOutCompletedHandler);			}catch(e:Error){}		}				private function removeItemManagerListeners ( p_itemManager : TransitionItemManager ) : void		{			try{				p_itemManager.transitionInCompleted.remove(transitionInCompletedHandler);				p_itemManager.transitionOutCompleted.remove(transitionOutCompletedHandler);			}catch(e:Error){}		}				private function createEntrySlot () : void		{			var exitItem : TransitionItemManager;						if(!(_activeCollection.isEmpty())){				exitItem = _activeCollection.get(0) as TransitionItemManager;				_activeCollection.remove(exitItem);			}else if(!(_arrivingCollection.isEmpty())){				exitItem = _arrivingCollection.get(0) as TransitionItemManager;				_arrivingCollection.remove(exitItem);			}else if(!(_queuedCollection.isEmpty())){				exitItem = _queuedCollection.get(0) as TransitionItemManager;				_queuedCollection.remove(exitItem);			}else{				throw new Error("All collections are empty but still failing. Check logic!");			}						_exitingCollection.add(exitItem);						processDepartures();		}				private function processDepartures () : void		{			var it : Iterator = _exitingCollection.iterator();						while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				if(item.currentState != TransitionItemManager.TRANSITIONING_OUT_STATE)item.transitionOut();			}		}				private function processArrivals () : void		{			var it : Iterator = _queuedCollection.iterator();						while(it.hasNext() && ((_activeCollection.size() + _arrivingCollection.size() + _exitingCollection.size()) < maxChildren)){				var item : TransitionItemManager = it.next() as TransitionItemManager;				_queuedCollection.remove(item)				_arrivingCollection.add(item);				item.transitionIn();			}		}					//--------------------------------------		//  HELPER METHODS		//--------------------------------------		private function hasAvailableSlot () : Boolean		{			var totalSlots : uint = (_queuedCollection.size() + _arrivingCollection.size() + _activeCollection.size());			return Boolean(totalSlots < maxChildren);		}				//--------------------------------------		//  HANDLER METHODS		//--------------------------------------				private function transitionInCompletedHandler ( p_itemManager : TransitionItemManager ) : void		{			_activeCollection.add(p_itemManager);			_arrivingCollection.remove(p_itemManager);							itemCompletedIn.dispatch(p_itemManager);						if(_arrivingCollection.isEmpty() && _queuedCollection.isEmpty())queueCompletedIn.dispatch();		}				private function transitionOutCompletedHandler ( p_itemManager : TransitionItemManager ) : void		{			destroyItemManager(p_itemManager);			processArrivals();						itemCompletedOut.dispatch(p_itemManager);						if(_exitingCollection.isEmpty() && _queuedCollection.isEmpty() && _arrivingCollection.isEmpty() && _activeCollection.isEmpty())queueCompletedOut.dispatch();		}					}}