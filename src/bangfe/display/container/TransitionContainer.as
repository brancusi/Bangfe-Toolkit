package bangfe.display.container{	import bangfe.core.TransitionableDisplayObject;	import bangfe.events.TransitionableEvent;		import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.errors.IllegalOperationError;	import flash.events.Event;		import org.osflash.signals.Signal;		import system.data.Iterator;	import system.data.collections.ArrayCollection;	/**	 * 	 * This is a simple transition container. Add a display object via addChild and the child will be transitioned on.	 * Old children will be transitioned off in an OUT then IN transition, according to how many children are allowed on stage	 * at the same time.	 * 	 * <br /><br />	 * 	 * There are 4 states a child can be in. OFF, TRANSITIONING_ON, ON, TRANSITIONING_OFF.	 * Map against the TransitionItemManager state constants.	 * 	 * <br/><br/>	 * 	 * This transition container acts like a pipe. Any child that's added will be pushed through the pipe to	 * a visible state. If an item is pushed out of the pipe, it will be destroyed once transitioned out.	 * 	 * <br/><br/>	 * 	 * By default the child count is virtually uncapped: uint.MAX_VALUE. Use the <code>maxChildren</code> property to 	 * set how many children should be allowed on the stage at a time.	 * 	 * <br/><br/>	 * 	 * For detailed transitions implement the <code>ITransitionable</code> interface.	 * 	 * <br/><br/>	 * 	 * If a child implements <code>ICoreObject</code>, it's destroy method will be called instead of direct removal.	 * 	 * <br/><br/>	 * 	 * Check the examples for usage 	 * 	 * <br/><br/>	 * 	 * @example This example demonstrates basic usage of the TransitionContainer.	 * 	 * <listing version="1.0">	 * 	 * 	import bangfe.display.container.TransitionContainer;     * 	import flash.display.Sprite;	 *      * 	public class DocClass extends Sprite     * 	{     * 		     * 		private var _transitionContainer : TransitionContainer;     * 		     * 		public function DocClass ()     * 		{     * 			_transitionContainer = new TransitionContainer();     * 			addChild(_transitionContainer);     * 		     * 			//Some visual object     * 			var testDisplayObject : TestDisplayObject = new TestDisplayObject();     * 			     * 			_transitionContainer.addChild(testDisplayObject);     * 			     * 			//A second visual object     * 			var testDisplayObject2 : TestDisplayObject = new TestDisplayObject();     * 			_transitionContainer.addChild(testDisplayObject2);     * 		}     * 		     * 	}	 * </listing>	 * 	 * @author Will Zadikian	 * 	 */	public class TransitionContainer extends TransitionableDisplayObject	{				//--------------------------------------		//  SIGNALS		//--------------------------------------		/**		 * Signal sent when the entire current queue is sucessfully transitioned on 		 */				public var queueCompletedIn : Signal = new Signal();				/**		 * Signal sent when the all items in the pipe are successfully transitioned out 		 */				public var queueCompletedOut : Signal = new Signal();				/**		 * Signal sent when a single item has transitioned in. Listener must expect 1 paramater of type <code>DisplayObject</code>		 */				public var itemCompletedIn : Signal = new Signal( DisplayObject );				/**		 * Signal sent when a single item transitions out. Listener must expect 1 paramater of type <code>DisplayObject</code>		 */				public var itemCompletedOut : Signal = new Signal( DisplayObject );				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------				private var _itemCollection : ArrayCollection = new ArrayCollection();		private var _maxChildren : uint = uint.MAX_VALUE;		private var _scope : DisplayObjectContainer;		private var _requestedTransitionOut : Boolean = false;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Add a child to the <code>TransitionContainer</code>. If the display object		 * implements <code>ITransitionable</code> it will hook into its transition in and out		 * methods. Otherwie it will do a default fade in/out.		 *  		 * @param child		 * @return 		 * 		 */		override public function addChild ( child : DisplayObject ) : DisplayObject		{			if(!hasAvailableSlot())createEntrySlot();						var item : TransitionItemManager = prepareItemManager(child);			_itemCollection.add(item);						processArrivals();						return child;		}				/** @private */				override public function addChildAt(child:DisplayObject, index:int):DisplayObject		{			throw new IllegalOperationError("addChildAt is not supported in TransitionContainer");		}				/**		 * Remove a child from the <code>TransitionContainer</code>. If the display object		 * implements <code>ITransitionable</code> it will hook into its transition in and out		 * methods. Otherwie it will do a default fade in/out.		 * @param child		 * @return 		 * 		 */				override public function removeChild(child:DisplayObject):DisplayObject		{			if(!containsChild(child))return null;			retrieveItemManagerWithChild(child).transitionOut();			return child;		}				/** @private */				override public function removeChildAt(index:int):DisplayObject		{			throw new IllegalOperationError("removeChildAt is not supported in TransitionContainer");		}				/**		 * Transition out all children of this container		 * 		 */		public function clear () : void		{			if(_itemCollection == null){				queueCompletedOut.dispatch();				return;			}						if(_itemCollection.isEmpty()){				queueCompletedOut.dispatch();				return;			}						var it : Iterator = _itemCollection.iterator();			while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				item.transitionOut();			}		}				/** @private */		override public function destroy():void		{			itemCompletedIn.removeAll();			itemCompletedOut.removeAll();			queueCompletedIn.removeAll();			queueCompletedOut.removeAll();						super.destroy();		}				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * Is the container empty of transitioned and queued items 		 * @return 		 * 		 */		public function get isEmpty () : Boolean		{			return _itemCollection.isEmpty();		}				/**		 * The max number of children allowed by the container. When the max is reached,		 * the bottom item in the stack will be replaced with the new request. First In First Out.		 *  		 * @return 		 * 		 */				public function get maxChildren () : uint		{			return _maxChildren;		}		public function set maxChildren ( p_maxChildren : uint ) : void		{			if(p_maxChildren < 1)throw new ArgumentError("Invalid value attempted for maxChildren. Value : " + p_maxChildren + " < 1 . Must be an int greater than 1"); 			_maxChildren = p_maxChildren;			trimCollection();		}				/**		 * The container to add children to 		 * @return 		 * 		 */				public function get scope () : DisplayObjectContainer		{			return _scope;		}		public function set scope ( p_scope : DisplayObjectContainer ) : void		{			_scope = p_scope;		}				/**		 * The number of queued items (awaiting a visible slot to be opened) outside of the pipe		 * @return 		 * 		 */				public function get numQueued () : int		{			return numberOfItemsWithState(TransitionItemManager.OFF_STATE);		}				/**		 * The number of arriving items (transition in) currently in the pipe 		 * @return 		 * 		 */				public function get numArriving () : int		{			return numberOfItemsWithState(TransitionItemManager.TRANSITIONING_IN_STATE);		}				/**		 * The number of active items (on screen in on state) currently in the pipe  		 * @return 		 * 		 */				public function get numActive () : int		{			return numberOfItemsWithState(TransitionItemManager.ON_STATE);		}				/**		 * The number of departing items (transitioning out) currently in the pipe  		 * @return 		 * 		 */				public function get numDeparting () : int		{			return numberOfItemsWithState(TransitionItemManager.TRANSITIONING_OUT_STATE);		}				/**		 * The number of items inside the pipe. The pipe being, active items plus transitioning items. 		 * @return 		 * 		 */				public function get numInPipe () : int		{			return (numActive + numArriving + numDeparting);		}				//--------------------------------------		//  PROTECTED METHODS		//--------------------------------------		/** @private */		override protected function setGlobalDefaults():void		{			maxChildren = uint.MAX_VALUE;						_scope = new Sprite();			super.addChild(_scope);			this.mouseEnabled = false;		}				//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------		private function prepareItemManager ( p_child : DisplayObject ) : TransitionItemManager		{			var transitionItemManager : TransitionItemManager = new TransitionItemManager(scope);			transitionItemManager.content = p_child;						addTransitionItemManagerListeners(transitionItemManager);						return transitionItemManager;			}				private function destroyItemManager ( p_item : TransitionItemManager = null ) : void		{			if(!p_item)return;						if(_itemCollection.contains(p_item))_itemCollection.remove(p_item);						removeItemManagerListeners(p_item);						p_item.destroy();		}				private function addTransitionItemManagerListeners ( p_item : TransitionItemManager ) : void		{			p_item.transitionInCompleted.add(transitionInCompletedHandler);			p_item.transitionOutCompleted.add(transitionOutCompletedHandler);		}				private function removeItemManagerListeners ( p_item : TransitionItemManager ) : void		{			p_item.transitionInCompleted.remove(transitionInCompletedHandler);			p_item.transitionOutCompleted.remove(transitionOutCompletedHandler);		}				private function createEntrySlot () : void		{			var it : Iterator = _itemCollection.iterator();						while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				if( (item.currentState == TransitionItemManager.ON_STATE) || 					(item.currentState == TransitionItemManager.TRANSITIONING_IN_STATE) || 					(item.currentState == TransitionItemManager.OFF_STATE)) {										item.transitionOut();					break;				}			}		}				private function processArrivals () : void		{			var it : Iterator = _itemCollection.iterator();						while(it.hasNext() && (numInPipe < maxChildren)){				var item : TransitionItemManager = it.next() as TransitionItemManager;				if(item.currentState == TransitionItemManager.OFF_STATE)item.transitionIn();			}		}					private function trimCollection () : void		{			var it : Iterator = _itemCollection.iterator();						while(it.hasNext() && (maxChildren < (numActive + numArriving))){				var item : TransitionItemManager = it.next() as TransitionItemManager;				item.transitionOut();			}		}				//--------------------------------------		//  HELPER METHODS		//--------------------------------------		private function hasAvailableSlot () : Boolean		{			var totalSlots : uint = (numQueued + numArriving + numActive);			return Boolean(totalSlots < maxChildren);		}				private function numberOfItemsWithState ( p_state : String ) : int		{			var it : Iterator = _itemCollection.iterator();						var count : int = 0;			while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				if(item.currentState == p_state)count++;			}						return count;		}				private function containsChild ( p_child : DisplayObject ) : Boolean		{			var it : Iterator = _itemCollection.iterator();						while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				if(item.content == p_child)return true;			}						return false;		}				private function retrieveItemManagerWithChild ( p_child : DisplayObject ) : TransitionItemManager		{			var it : Iterator = _itemCollection.iterator();						while(it.hasNext()){				var item : TransitionItemManager = it.next() as TransitionItemManager;				if(item.content == p_child)return item;			}						return null;		}		//--------------------------------------		//  HANDLER METHODS		//--------------------------------------		private function transitionInCompletedHandler ( p_item : TransitionItemManager ) : void		{							itemCompletedIn.dispatch(p_item.content);			if((numArriving + numQueued) < 1)queueCompletedIn.dispatch();		}				private function transitionOutCompletedHandler ( p_item : TransitionItemManager ) : void		{			destroyItemManager(p_item);			processArrivals();						itemCompletedOut.dispatch(p_item.content);						if(_itemCollection.isEmpty())queueCompletedOut.dispatch();		}					}}