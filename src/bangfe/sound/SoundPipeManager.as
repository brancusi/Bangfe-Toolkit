package bangfe.sound{	import bangfe.core.ICoreObject;	import bangfe.sound.pipe.BaseSoundPipe;	import bangfe.sound.pipe.CircularSoundPipe;	import bangfe.sound.pipe.ConcurrentSoundPipe;	import bangfe.sound.pipe.LinearSoundPipe;	import bangfe.sound.pipe.SingleSoundPipe;	import bangfe.sound.pipe.SoundPipeType;		import com.greensock.events.LoaderEvent;	import com.greensock.loading.LoaderMax;	import com.greensock.loading.MP3Loader;	import com.greensock.loading.XMLLoader;	import com.greensock.loading.core.LoaderItem;		import flash.errors.IllegalOperationError;	import flash.events.Event;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;		import org.osflash.signals.Signal;		import system.data.Iterator;	import system.data.maps.HashMap;		/**	 * This is a facade for <code>SoundTrack</code> instances. It helps with creation	 * storage and destruction of soundtracks. It also has short cuts for global	 * muting and unmuting, as well as playing sounds.	 * 	 * For specific soundtrack behavior, deal directly with the returned	 * <code>SoundTrack</code> instance 	 * 	 * @author Will Zadikian	 * 	 */		public class SoundPipeManager implements ICoreObject	{				//--------------------------------------		//  PUBLIC STATIC CONSTANTS		//--------------------------------------		public static const DEFAULT_PIPE : String = "__defaultPipe__";				//--------------------------------------		//  SIGNALS		//--------------------------------------		public var enabledStateChangedSignal : Signal = new Signal(Boolean);				//--------------------------------------		//  INJECTED PROPETIES		//--------------------------------------				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var _pipeMap : HashMap = new HashMap();		private var _enabled : Boolean = true;		private var _paused : Boolean = false;				//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Constructor 		 * 		 */		public function SoundPipeManager () : void		{			init();		}				/**		 * Play a specific sound based on ID. This will attempt to load from previously		 * loaded loadermax sounds, using the static <code>LoaderMax.getLoader()</code> method		 * 		 * @param p_soundID The sound id to mine from LoaderMax		 * @param p_track The track id to play the sound on default is <code>DEFAULT_TRACK</code>		 * @param p_transform An optional SoundTransform to apply to the sound		 * 		 */						public function playSoundWithID ( p_soundID : String, p_pipeID : String = DEFAULT_PIPE, p_transform : SoundTransform = null ) : void		{			if(!enabled)return;			if(paused)return;			if(!hasPipeWithID(p_pipeID))throw new Error("No pipe with ID : " + p_pipeID + " was found");						var loader : LoaderItem = LoaderMax.getLoader(p_soundID);			if(loader is MP3Loader){				var sound : Sound =  MP3Loader(loader).content;				var soundPipeItem : SoundPipeItem = new SoundPipeItem(sound, p_transform);				getPipe(p_pipeID).playSound(soundPipeItem);			}else{				throw new Error("No LoaderMax instance with ID : " + p_soundID + " was found");			}		}				/**		 * Plays a sound already loaded into memory		 * 		 * @param p_sound The sound to play		 * @param p_track The track id to play the sound on default is <code>DEFAULT_TRACK</code>		 * @param p_transform An optional SoundTransform to apply to the sound		 * 		 */				public function playSound ( p_sound : Sound, p_pipeID : String = DEFAULT_PIPE, p_transform : SoundTransform = null ) : void		{			if(!enabled)return;			if(paused)return;			if(!hasPipeWithID(p_pipeID))throw new Error("No pipe with ID : " + p_pipeID + " was found");						var soundPipeItem : SoundPipeItem = new SoundPipeItem(p_sound, p_transform);						getPipe(p_pipeID).playSound(soundPipeItem);		}				/**		 * Create a new track. Attempting to create a new soundtrack 		 * with an ID already in use will throw an error.		 * 		 * @param p_trackID The ID of the soundtrack		 * @return 		 * 		 */				public function createPipe ( p_pipeID : String, p_type : String = SoundPipeType.SINGLE ) : BaseSoundPipe		{			if(hasPipeWithID(p_pipeID))throw new Error("A pipe with ID : " + p_pipeID + " already exsists");						if(!isValidSoundPipe(p_type))throw new Error("You must use a sound pipe defined by the SoundPipeType list");						var soundPipe : BaseSoundPipe = generatePipe(p_type);						_pipeMap.put(p_pipeID, soundPipe);						return soundPipe;		}				/**		 * Get a sound track by ID  		 * @param p_trackID The ID of the soundtrack		 * @return 		 * 		 */				public function getPipe ( p_pipeID : String ) : BaseSoundPipe		{			if(hasPipeWithID(p_pipeID))return _pipeMap.get(p_pipeID);						return null;		}				/**		 * Does the track manager have a track with the specified ID		 *  		 * @param p_trackID The track ID to check for		 * @return 		 * 		 */				public function hasPipeWithID ( p_trackID : String ) : Boolean		{			return (_pipeMap.containsKey(p_trackID));		}				/**		 * Destroy the sound manager 		 * 		 */				public function destroy () : void		{			var it : Iterator = _pipeMap.iterator();						while(it.hasNext()){				var soundPipe : BaseSoundPipe = it.next() as BaseSoundPipe;				soundPipe.destroy();			}						_pipeMap.clear();		}				/**		 * Kill all sounds currently being played 		 * 		 */				public function killAllSound () : void		{			var it : Iterator = _pipeMap.iterator();						while(it.hasNext()){				var soundPipe : BaseSoundPipe = it.next() as BaseSoundPipe;				soundPipe.killAllSound();			}		}				/**		 * Pause all sounds currently being played 		 * 		 */				public function pauseAllSound () : void		{			_paused = true;						var it : Iterator = _pipeMap.iterator();						while(it.hasNext()){				var soundPipe : BaseSoundPipe = it.next() as BaseSoundPipe;				soundPipe.pause();			}		}				/**		 * Resume all sounds currently being playerd 		 * 		 */				public function resumeAllSound () : void		{			_paused = false;						var it : Iterator = _pipeMap.iterator();						while(it.hasNext()){				var soundPipe : BaseSoundPipe = it.next() as BaseSoundPipe;				soundPipe.resume();			}		}				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * Are sounds currently enabled. Useful for global muting/unmuting		 * @return 		 * 		 */				public function get enabled () : Boolean		{			return _enabled;		}				public function set enabled ( p_enabled : Boolean) : void		{			if(_enabled == p_enabled)return;			_enabled = p_enabled;						if(!_enabled){				pauseAllSound();			}else{				resumeAllSound();			}						//Dispatch change			enabledStateChangedSignal.dispatch(_enabled);		}				/**		 * Is this manager paused 		 * @return 		 * 		 */				public function get paused () : Boolean		{			return _paused;		}				//--------------------------------------		//  PRIVATE METHODS		//--------------------------------------				private function init () : void		{			setDefaults();		}				private function setDefaults () : void		{			createPipe(DEFAULT_PIPE);		}				private function isValidSoundPipe ( p_type : String ) : Boolean		{			return (SoundPipeType.TYPE_ENUM.contains(p_type));		}				/**		 * Factory method. Generates a pipe of the corresponding type 		 * @param p_type		 * @return 		 * 		 */				private function generatePipe ( p_type : String ) : BaseSoundPipe		{			switch(p_type){				case SoundPipeType.SINGLE : 					return new SingleSoundPipe();					break;								case SoundPipeType.LINEAR : 					return new LinearSoundPipe();					break;								case SoundPipeType.CONCURRENT : 					return new ConcurrentSoundPipe();					break;								case SoundPipeType.CIRCULAR : 					return new CircularSoundPipe();					break;			}						throw new Error("No pipe could be created. Type "+p_type+"was not found");		}				//--------------------------------------		//  HANDLER METHODS		//--------------------------------------					}}