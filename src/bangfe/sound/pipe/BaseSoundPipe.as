package bangfe.sound.pipe{	import bangfe.core.ICoreObject;	import bangfe.sound.SoundPipeItem;		import com.greensock.TweenLite;	import com.greensock.plugins.TweenPlugin;	import com.greensock.plugins.VolumePlugin;		import flash.events.Event;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;		import org.osflash.signals.Signal;		import system.data.Iterator;	import system.data.collections.ArrayCollection;		/**	 * A sound pipe plays <code>SoundPipeItem</code>s. It differs	 * from a traditional sound track in that it doesn't retain sounds.	 * It plays sounds through and then dumps them.	 * 	 * The only time the pipe retains sound is when looping is enabled.	 * In which case the pipe acts as an circle.	 *  	 * @author Will Zadikian	 * 	 */		public class BaseSoundPipe implements ICoreObject	{				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var _volume : Number = .05;		private var _isPaused : Boolean = false;				//--------------------------------------		//  PROTECTED VARIABLES		//--------------------------------------		private var _soundPipeItemCollection : ArrayCollection = new ArrayCollection();				//--------------------------------------		//  SIGNALS		//--------------------------------------		/**		 * Dispatched when the track starts playback 		 */		public var pipeStartedSignal : Signal = new Signal(BaseSoundPipe);				/**		 * Dispatched when the track completes playback 		 */				public var pipeCompletedSignal : Signal = new Signal(BaseSoundPipe);		//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		/**		 * Constructor 		 * 		 */		public function BaseSoundPipe()		{			init();		}				/**		 * Destroy the track 		 * 		 */				public function destroy () : void		{			pipeStartedSignal.removeAll();			pipeCompletedSignal.removeAll();						var it : Iterator = collectionIterator;						while(it.hasNext()){				var soundPipeItem : SoundPipeItem = it.next() as SoundPipeItem;				soundPipeItem.destroy();			}						_soundPipeItemCollection.clear();		}				/**		 * Play a sound on this track 		 * @param p_sound The sound to play		 * @param p_transform The 		 * 		 */				public function playSound ( p_soundPipeItem : SoundPipeItem ) : void		{			//Can we even play a sound right now			if(!canPlaySound())return;						//If the sound item is already in the collection exit out			if(_soundPipeItemCollection.contains(p_soundPipeItem))return;						//Add to the collection			addSound(p_soundPipeItem);						//Handle playback in subclass			handleSoundPlayRequested(p_soundPipeItem);		}				/**		 * Remove a sound from the pipe 		 * @param p_soundPipeItem		 * 		 */				public function removeSound ( p_soundPipeItem : SoundPipeItem ) : void		{			try{				_soundPipeItemCollection.remove(p_soundPipeItem);			}catch(e:Error){}						p_soundPipeItem.destroy();						removeSoundPipeItemListeners(p_soundPipeItem);		}				/**		 * Kill all sounds in this pipe 		 * 		 */				public function killAllSound () : void		{			var it : Iterator = collectionIterator;						while(it.hasNext()){				var soundPipeItem : SoundPipeItem = it.next() as SoundPipeItem;				soundPipeItem.destroy();			}						_soundPipeItemCollection.clear();						pipeCompletedSignal.dispatch(this);		}				/**		 * Pause playback of all sounds in the pipe 		 * 		 */				public function pause ( p_instant : Boolean = false ) : void		{			if(isPaused)return;			_isPaused = true;						var it : Iterator = collectionIterator;						while(it.hasNext()){				var soundPipeItem : SoundPipeItem = it.next() as SoundPipeItem;				soundPipeItem.pause(p_instant);			}		}				/**		 * Resume playback of all sound in the pipe 		 * 		 */				public function resume ( p_instant : Boolean = false ) : void		{			if(!isPaused)return;			_isPaused = false;						var it : Iterator = collectionIterator;						while(it.hasNext()){				var soundPipeItem : SoundPipeItem = it.next() as SoundPipeItem;				soundPipeItem.resume(p_instant);			}		}				//--------------------------------------		//  ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * The track volume. This will dim sound in relation to		 * global sound scale for this track		 *  		 * @return 		 * 		 */				public function get volume () : Number		{			return _volume;		}				public function set volume ( p_volume : Number ) : void		{			_volume = p_volume;						var it : Iterator = collectionIterator;						while(it.hasNext()){				var soundPipeItem : SoundPipeItem = it.next() as SoundPipeItem;				soundPipeItem.volume = p_volume;			}		}				/**		 * Is the sound track currently paused 		 * @return 		 * 		 */				public function get isPaused () : Boolean		{			return _isPaused;		}				//--------------------------------------		//  INTERNAL ACCESSOR/MUTATOR METHODS		//--------------------------------------		/**		 * The <code>SoundPipeItem</code> instance collection 		 * @return 		 * 		 */		protected function get collectionIterator () : Iterator		{			return _soundPipeItemCollection.iterator();		}				//--------------------------------------		//  OVERRIDE METHODS		//--------------------------------------		protected function setDefaults () : void		{			//Override		}				/**		 * Can the track play a sound right now. Override in specific track types 		 * @return 		 * 		 */				protected function canPlaySound () : Boolean		{			//Override			return true;		}				/**		 * What to do with a newly added song. Override in specific track types 		 * @param p_soundPipeItem		 * 		 */				protected function handleSoundPlayRequested ( p_soundPipeItem : SoundPipeItem ) : void		{			//Override		}				/**		 * What to do on sound start 		 * @param p_soundPipeItem		 * 		 */				protected function handleSoundStarted ( p_soundPipeItem : SoundPipeItem ) : void		{			//Override 		}				/**		 * What to do on sound complete. Override in specific track types 		 * @param p_soundPipeItem		 * 		 */				protected function handleSoundCompleted ( p_soundPipeItem : SoundPipeItem ) : void		{			//Override 		}				//--------------------------------------		//  PROTECTED METHODS		//--------------------------------------		private function init () : void		{			setGlobalDefaults();			setDefaults();		}				private function setGlobalDefaults () : void		{			TweenPlugin.activate([VolumePlugin]);		}				/**		 * Adds the sound to the array collection and sets up listeners 		 * @param p_soundPipeItem		 * 		 */				private function addSound ( p_soundPipeItem : SoundPipeItem ) : void		{			_soundPipeItemCollection.add(p_soundPipeItem);			addSoundPipeItemListeners(p_soundPipeItem);		}				private function addSoundPipeItemListeners ( p_soundPipeItem : SoundPipeItem ) : void		{			p_soundPipeItem.playbackStarted.add(handleSoundStarted);			p_soundPipeItem.playbackCompleted.add(handleSoundCompleted);		}				private function removeSoundPipeItemListeners ( p_soundPipeItem : SoundPipeItem ) : void		{			p_soundPipeItem.playbackStarted.remove(handleSoundStarted);			p_soundPipeItem.playbackCompleted.remove(handleSoundCompleted);		}					}}